# -*- coding: utf-8 -*-
"""net.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SBNxzS8twORbT-hrezaC4Okw3h0S_hAy
"""

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import tensorflow as tf
x = tf.constant(4)
print(x)
x = tf.constant([2,3,4])
print(x)
x = tf.constant ([[1,2],
                  [3,4],
                  [5,6]], dtype = tf.float16)
print(x)

#
x = tf.ones((3, 3))
print(x)
x = tf.eye(3)
print(x)
x = tf.random.normal((3, 3), mean=0, stddev=1)
print(x)
x = tf.random.uniform((1, 3), minval=0, maxval=1)
print(x)
x = tf.range(start=1, limit=10, delta=2)
print(x)

x = tf.constant([1,2,3])
y = tf.constant([9,8,7])
z = tf.add(x,y)
print(z)
z = x+y
print(z)
z = tf.divide(x,y)
print(z)
z = x/y
print(z)
#First change razmernost (tranponirovat on of vector)
z = tf.multiply(x,y)
print(z)
z = x*y
print(z)
z = tf.tensordot(x,y, axes = 1)
print(z)
z = tf.reduce_sum(x*y, axis = 0)
print(z)
z = x**5
print(z)

import tensorflow as tf
from tensorflow import keras
from keras import layers
from keras.datasets import mnist
import numpy
import matplotlib.pyplot as plt

# x testovaya vyborka, y - verdikty po kazhdoy kartinke x==y
(x_train, y_train), (x_test0, y_test) = mnist.load_data()
print('Train : X = %s, y = %s' % (x_train.shape, y_train.shape) )
print('Test : X = %s, y = %s' % (x_test0.shape, y_test.shape) )


x_train = x_train.reshape(-1, 28*28).astype("float32")/255.0
x_test = x_test0.reshape(-1, 28*28).astype("float32")/255.0
print('Train : X = %s, y = %s' % (x_train.shape, y_train.shape) )
print('Test : X = %s, y = %s' % (x_test.shape, y_test.shape) )
print(x_test[0])

model = keras.Sequential(
    [
        keras.Input(shape=(28*28)),
        layers.Dense(512, activation='relu'),
        layers.Dense(256, activation='relu'),
        layers.Dense(10),
    ]
)

model.compile(
    loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    optimizer=keras.optimizers.Adam(lr=0.001),
    metrics=["accuracy"]
)
model.fit(x_train, y_train, batch_size=32, epochs=10, verbose=2)
model.evaluate(x_test, y_test, batch_size=32, verbose=2)


model.summary()

predictions = model.predict(x_test)
predictions[0]

verdict = model.predict(x_test)
#print("Application %d predicting using train set %s result is %s" % (3,x_test.shape, verdicts.shape))
for i in range(10):
   print(numpy.argmax(verdict[i]))

class_names = ['0', '1', '2', '3', '4', '5', '6','7', '8', '9' ]

plt.figure(figsize = (10,10))
for i in range(25):
  plt.subplot(5,5,i+1)
  plt.xticks([])
  plt.yticks([])
  plt.imshow(x_test0[i], cmap = plt.cm.binary)
  plt.xlabel(class_names[numpy.argmax(verdict[i])])

model.save("model.h5")

"""Фильтры фотошопа, подобрать фильтры через опен сиви, для того чтобы поменять входное изобраджение, 1. распознать сфотканную собой цифру, и подобрать фильтр, любой 2 бабор йифр отфотошопить так чтобы стало очевидно что есть 7 элементов(тип колво цифр) задлача сегментации и т д зрение грамотная сегментация, картинка сегментация распознования придумать способ"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from tensorflow.keras.preprocessing.image import img_to_array
def prepImg(data):
    return cv2.resize(data,(28,28)).reshape(28*28)/255.0

img = cv2.imread('/content/1.png')
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
blur = cv2.GaussianBlur(gray, (5,5) , 0)
ret , im_th = cv2.threshold(blur, 180 , 400 , cv2.THRESH_BINARY_INV)
ctrs , hier = cv2.findContours(im_th.copy(),cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
rects = [cv2.boundingRect(ctr) for ctr in ctrs]

cv2_imshow(im_th)

for x,y,w,h in rects :

    if y>=3:
        y-=3
    else :
        y=0
    if x>=3:
        x-=3
    else:
        x=0
    w+=3
    h+=3
    cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)
    sliced = im_th[y:y+h,x:x+w]
    thresh = cv2.threshold(sliced, 0, 255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
    sliced = img_to_array(sliced,dtype='float32')
    sliced = prepImg(sliced)
    sliced = np.expand_dims(sliced , axis = 0)
    prediction = model.predict(sliced)
    print(np.argmax(prediction))
    cv2.putText(img, str(np.argmax(prediction)), (x,y+int(h/2)), cv2.FONT_HERSHEY_SIMPLEX ,  1, (0,255,0) , 2, cv2.LINE_AA)
cv2_imshow(img)